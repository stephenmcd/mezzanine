#
# Eduardo Rivas <jerivasmelgar@gmail.com>, 2014.
#
msgid ""
msgstr ""
"Project-Id-Version: Mezzanine 3.1.9\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2014-08-19 13:59-0600\n"
"PO-Revision-Date: 2014-09-28 21:38-0600\n"
"Last-Translator: Eduardo Rivas <jerivasmelgar@gmail.com>\n"
"Language-Team: Español; Castellano <>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"X-Generator: Gtranslator 2.91.6\n"

#: ../content-architecture.rst:3
msgid "Content Architecture"
msgstr "Arquitectura de contenido"

#: ../content-architecture.rst:5
msgid ""
"Content in Mezzanine primarily revolves around the models found in two "
"packages, ``mezzanine.core`` and ``mezzanine.pages``. Many of these models "
"are abstract, and very small in scope, and are then combined together as the "
"building blocks that form the models you'll actually be exposed to, such as "
"``mezzanine.core.models.Displayable`` and ``mezzanine.core.pages.Page``, "
"which are the two main models you will inherit from when building your own "
"models for content types."
msgstr ""
"En Mezzanine, el contenido gira alrededor de los modelos que se encuentran "
"dos paquetes: ``mezzanine.core`` y ``mezzanine.pages``. Muchos de estos "
"modelos son abstractos y de un alcance pequeño, y son combinados como los "
"bloques de construcción de los modelos a los que el desarrollador es "
"expuesto. Este es el caso de ``mezzanine.core.models.Displayable`` y "
"``mezzanine.core.pages.Page``, los cuales son los dos modelos principales de "
"los cuales se debe heredar para construir modelos propios para tipos de "
"contenidos."

#: ../content-architecture.rst:13
msgid ""
"Before we look at ``Displayable`` and ``Page``, here's a quick list of all "
"the abstract models used to build them:"
msgstr ""
"Antes de echar un vistazo a ``Displayable`` y ``Page``, se presenta la lista "
"de modelos abstractos de los que están construidos:"

#: ../content-architecture.rst:16
msgid ""
"``mezzanine.core.models.SiteRelated`` - Contains a related ``django.contrib."
"sites.models.Site`` field."
msgstr ""
"``mezzanine.core.models.SiteRelated`` - Contiene un campo relacionado a "
"``django.contrib.sites.models.Site``."

#: ../content-architecture.rst:18
msgid "``mezzanine.core.models.Slugged`` - Implements a title and URL (slug)."
msgstr "``mezzanine.core.models.Slugged`` - Implementa un título y URL (slug)."

#: ../content-architecture.rst:20
msgid ""
"``mezzanine.core.models.MetaData`` - Provides SEO meta data, such as title, "
"description and keywords."
msgstr ""
"``mezzanine.core.models.MetaData`` - Provee metadatos para SEO, como título, "
"descripción y palabras clave."

#: ../content-architecture.rst:22
msgid ""
"``mezzanine.core.models.TimeStamped`` - Provides created and updated "
"timestamps."
msgstr ""
"``mezzanine.core.models.TimeStamped`` - Almacena fechas de creación y "
"modificación."

#: ../content-architecture.rst:24
msgid ""
"``mezzanine.core.models.Displayable`` - Combines all the models above, then "
"implements publishing features, such as status and dates."
msgstr ""
"``mezzanine.core.models.Displayable`` - Combina todos los modelos anteriores "
"e implementa características de publicación como estado de publicación y "
"fechas."

#: ../content-architecture.rst:27
msgid ""
"``mezzanine.core.models.Ownable`` - Contains a related user field, suitable "
"for content owned by specific authors."
msgstr ""
"``mezzanine.core.models.Ownable`` - Contiene un campo relacionado a un "
"usuario, ideal para contenido que pertenece a autores específicos."

#: ../content-architecture.rst:29
msgid "``mezzanine.core.models.RichText`` - Provides a WYSIWYG editable field."
msgstr "``mezzanine.core.models.RichText`` - Provee un campo editable LQVELQO."

#: ../content-architecture.rst:31
msgid ""
"``mezzanine.core.models.Orderable`` - Used to implement drag/drop ordering "
"of content, whether out of the box as Django admin inlines, or custom such "
"as Mezzanine's page tree."
msgstr ""
"``mezzanine.core.models.Orderable`` - Utilizado para implementar "
"ordenamiento de contenido por arrastrar-y-soltar, ya sea para instancias "
"Django estándar inline, o instancias personalizadas en el árbol de páginas "
"de Mezzanine."

#: ../content-architecture.rst:35
msgid ""
"And for completeness, here are the primary content types provided out of the "
"box to end users, that make use of ``Displayable`` and ``Page``:"
msgstr ""
"También se presentan los principales tipos de contenido provistos por "
"defecto a los usuarios finales, que hacen uso de ``Displayable`` y ``Page``:"

#: ../content-architecture.rst:39
msgid ""
"``mezzanine.blog.models.BlogPost`` - Blog posts that subclass "
"``Displayable`` as they're not part of the site's navigation."
msgstr ""
"``mezzanine.blog.models.BlogPost`` - Las entradas de blog son subclases de "
"``Displayable`` ya que no forman parte de la navegación del sitio."

#: ../content-architecture.rst:41
msgid ""
"``mezzanine.pages.models.RichTextPage`` - Default ``Page`` subclass, "
"providing a WYSIWYG editable field."
msgstr ""
"``mezzanine.pages.models.RichTextPage`` - Subclase por defecto de ``Page`` "
"que provee un campo editable LQVELQO."

#: ../content-architecture.rst:43
msgid ""
"``mezzanine.pages.models.Link`` - ``Page`` subclass for links pointing to "
"other URLs."
msgstr ""
"``mezzanine.pages.models.Link`` - Subclase de ``Page`` para enlaces "
"apuntando a otras URLs."

#: ../content-architecture.rst:45
msgid "``mezzanine.forms.models.Form`` - ``Page`` subclass for building forms."
msgstr ""
"``mezzanine.forms.models.Form`` - Subclase de ``Page`` para crear "
"formularios."

#: ../content-architecture.rst:47
msgid ""
"``mezzanine.galleries.models.Gallery`` - ``Page`` subclass for building "
"image gallery pages."
msgstr ""
"``mezzanine.galleries.models.Gallery`` - Subclase de ``Page`` para crear "
"galerías de imágenes."

#: ../content-architecture.rst:50
msgid ""
"These certainly serve as examples for implementing your own types of content."
msgstr ""
"Estos casos funcionan como ejemplo para implementar tipos de contenido "
"personalizados."

#: ../content-architecture.rst:54
msgid "``Displayable`` vs ``Page``"
msgstr "``Displayable`` vs ``Page``"

#: ../content-architecture.rst:56
msgid ""
"``Displayable`` itself is also an abstract model, that at its simplest, is "
"used to represent content that contains a URL (also known as a slug). It "
"also provides the core features of content such as:"
msgstr ""
"``Displayable`` en sí es un modelo abstracto, que en el caso más simple es "
"utilizado para representar cualquier contenido que contenga una URL (también "
"conocida como slug). Además provee las principales características de "
"contenido como:"

#: ../content-architecture.rst:60
msgid "Meta data such as a title, description and keywords."
msgstr "Meta datos como título, descripción y palabras clave."

#: ../content-architecture.rst:61
msgid "Auto-generated slug from the title."
msgstr "URL auto-generada del título."

#: ../content-architecture.rst:62
msgid "Draft/published status with the ability to preview drafts."
msgstr ""
"Esta de publicación (borrador/publicado) con la posibilidad de previsualizar "
"borradores."

#: ../content-architecture.rst:63
msgid "Pre-dated publishing."
msgstr "Publicación programada."

#: ../content-architecture.rst:64
msgid "Searchable by Mezzanine's :doc:`search-engine`."
msgstr "Indexable por el :doc:`search-engine` de Mezzanine."

#: ../content-architecture.rst:66
msgid ""
"Subclassing ``Displayable`` best suits low-level content that doesn't form "
"part of the site's navigation - such as blog posts, or events in a calendar. "
"Unlike ``Page``, there's nothing particularly special about the "
"``Displayable`` model - it simply provides a common set of features useful "
"to content."
msgstr ""
"Se recomienda que el contenido de bajo nivel que no sea parte de la "
"navegación del sitio sea una subclase de ``Displayable``, esto incluye "
"entradas de blog, o eventos de un calendario . A diferencia de ``Page``, no "
"hay nada especial en cuanto al modelo ``Displayable`` - simplemente provee "
"un conjunto de características comunes de utilidad para el contenido."

#: ../content-architecture.rst:72
msgid ""
"In contrast, the concrete ``Page`` model forms the primary API for building "
"a Mezzanine site. It extends ``Displayable``, and implements a hierarchical "
"navigation tree. The rest of this section of the documentation will focus on "
"the ``Page`` model, and the way it is used to build all the types of content "
"a site will have available."
msgstr ""
"En contraste, ``Page`` es un modelo concreto que funciona como la API "
"principal para construir un sitio Mezzanine. Es una subclase de "
"``Displayable`` e implementa un árbol de navegación jerárquico. El resto de "
"este documento se concentrará en el modelo ``Page`` y en la forma en que es "
"utilizado para construir todos los tipos de contenido disponibles."

#: ../content-architecture.rst:79
msgid "The ``Page`` Model"
msgstr "El modelo ``Page``"

#: ../content-architecture.rst:81
msgid ""
"The foundation of a Mezzanine site is the model ``mezzanine.pages.models."
"Page``. Each ``Page`` instance is stored in a hierarchical tree to form the "
"site's navigation, and an interface for managing the structure of the "
"navigation tree is provided in the admin via ``mezzanine.pages.admin."
"PageAdmin``. All types of content inherit from the ``Page`` model and "
"Mezzanine provides a default content type via the ``mezzanine.pages.models."
"RichTextPage`` model which simply contains a WYSIWYG editable field for "
"managing HTML content."
msgstr ""
"El fundamento de un sitio Mezzanine es el modelo ``mezzanine.pages.models."
"Page``. Cada instancia de ``Page`` es almacenada en un árbol jerárquico que "
"constituye la navegación del sitio. Se provee una interfaz para gestionar la "
"estructura del árbol de navegación en el sitio administrativo a través de "
"``mezzanine.pages.admin.PageAdmin``. Todo tipo de contenido hereda del "
"modelo ``Page``, y Mezzanine provee el modelo ``mezzanine.pages.models."
"RichTextPage`` para permitir la edición de contenido HTML a través del campo "
"LQVELQO."

#: ../content-architecture.rst:93
msgid "Creating Custom Content Types"
msgstr "Creación de tipos de contenido personalizados"

#: ../content-architecture.rst:95
msgid ""
"In order to handle different types of pages that require more structured "
"content than provided by the ``RichTextPage`` model, you can simply create "
"your own models that inherit from ``Page``. For example if we wanted to have "
"pages that were authors with books::"
msgstr ""
"Para gestionar diferentes tipos de página que requieren contenido más "
"estructurado que el provisto por el modelo ``RichTextPage``, simplemente se "
"deben crear modelos que sean una subclase de ``Page``. Por ejemplo, para "
"crear páginas donde cada una represente un autor con los libros que ha "
"escrito::"

#: ../content-architecture.rst:116
msgid ""
"Next you'll need to register your model with Django's admin to make it "
"available as a content type. If your content type only exposes some new "
"fields that you'd like to make editable in the admin, you can simply "
"register your model using the ``mezzanine.pages.admin.PageAdmin`` class::"
msgstr ""
"Luego se debe registrar el modelo con la interfaz administrativa de Django "
"para tenerlo disponible como tipo de contenido. Si el nuevo tipo de "
"contenido sólo expone algunos campos nuevos para ser editados en la interfaz "
"administrativa, sencillamente se debe registar el modelo utilizando la clase "
"``mezzanine.pages.admin.PageAdmin``::"

#: ../content-architecture.rst:128
msgid ""
"Any regular model fields on your content type will be available when adding "
"or changing an instance of it in the admin. This is similar to Django's "
"behaviour when registering models in the admin without using an admin class, "
"or when using an admin class without fieldsets defined. In these cases all "
"the fields on the model are available in the admin."
msgstr ""
"Todos los campos del modelo estarán disponibles al añadir o editar las "
"instancias del nuevo tipo de contenido en la interfaz administrativa. Esto "
"es similar al comportamiento de Django al registrar modelos en la interfaz "
"administrativa sin utilizar una clase admin, o cuando se utiliza una clase "
"admin sin fieldsets definidos. En estos casos todos los campos del modelo "
"están disponibles en la interfaz administrativa."

#: ../content-architecture.rst:134
msgid ""
"If however you need to customize your admin class, you can inherit from "
"``PageAdmin`` and implement your own admin class. The only difference is "
"that you'll need to take a copy of ``PageAdmin.fieldsets`` and modify it if "
"you want to implement your own fieldsets, otherwise you'll lose the fields "
"that the ``Page`` model implements::"
msgstr ""
"Si es necesario editar la clase admin, se debe heredar de ``PageAdmin`` e "
"implementar una clase propia. La única diferencia es que será necesario "
"hacer una copia de ``PageAdmin.fieldsets`` y modificarla para implementar "
"fieldsets personalizados, de otra manera se perderán los campos "
"implementados por el modelo ``Page``::"

#: ../content-architecture.rst:156
msgid ""
"When registering content type models with ``PageAdmin`` or subclasses of it, "
"the admin class won't be listed in the admin index page, instead being made "
"available as a type of ``Page`` when creating new pages from the navigation "
"tree."
msgstr ""
"Cuando se registren tipos de contenido usando la clase ``PageAdmin`` o "
"alguna subclase de ella, la clase admin no será mostrada en la página "
"inicial de la interfaz administrativa. En cambio, estará disponible como un "
"nuevo tipo de ``Page`` al crear nuevas páginas en el árbol de navegación."

#: ../content-architecture.rst:163
msgid ""
"When creating custom content types, you must inherit directly from the "
"``Page`` model. Further levels of subclassing are currently not supported. "
"Therefore you cannot subclass the ``RichTextPage`` or any other custom "
"content types you create yourself. Should you need to implement a WYSIWYG "
"editable field in the way the ``RichTextPage`` model does, you can simply "
"subclass both ``Page`` and ``RichText``, the latter being imported from "
"``mezzanine.core.models``."
msgstr ""
"Al crear tipos de contenido personalizados, se debe heredar directamente del "
"modelo ``Page``. Los niveles más profundos de subclases no son soportados "
"actualmente. Esto significa que no se pueden crear subclases basadas en "
"``RichTextPage`` o ningún otro tipo de contenido personalizado. Si fuera "
"necesario implementar un campo LQVELQO de la misma manera en que "
"``RichTextPage`` lo hace, simplemente se debe heredar de ``Page`` y "
"``RichText``. Este último debe ser importado de ``mezzanine.core.models``."

#: ../content-architecture.rst:173
msgid "Displaying Custom Content Types"
msgstr "Mostrando tipos de contenido personalizados"

#: ../content-architecture.rst:175
msgid ""
"When creating models that inherit from the ``Page`` model, multi-table "
"inheritance is used under the hood. This means that when dealing with the "
"page object, an attribute is created from the subclass model's name. So "
"given a ``Page`` instance using the previous example, accessing the "
"``Author`` instance would be as follows::"
msgstr ""
"Al crear modelos que heredan del modelo ``Page``, se utilizará herencia "
"multi-tabla tras escenarios. Esto significa que al tratar con el objeto "
"``Page`` se le creará un atributo a partir del nombre del modelo "
"personalizado. Teniendo la instancia ``Page`` del ejemplo anterior, la forma "
"de acceder a la instancia del modelo ``Author`` es::"

#: ../content-architecture.rst:187
msgid "And in a template::"
msgstr "Y en una plantilla::"

#: ../content-architecture.rst:195
msgid ""
"The ``Page`` model also contains the method ``Page.get_content_model`` for "
"retrieving the custom instance without knowing its type::"
msgstr ""
"El modelo ``Page`` también contiene el método ``Page.get_content_model`` "
"para recuperar la instancia del modelo personalizado sin saber su tipo de "
"antemano::"

#: ../content-architecture.rst:202
msgid "Page Templates"
msgstr "Plantillas Page"

#: ../content-architecture.rst:204
msgid ""
"The view function ``mezzanine.pages.views.page`` handles returning a "
"``Page`` instance to a template. By default the template ``pages/page.html`` "
"is used, but if a custom template exists it will be used instead. The check "
"for a custom template will first check for a template with the same name as "
"the ``Page`` instance's slug, and if not then a template with a name derived "
"from the subclass model's name is checked for. So given the above example "
"the templates ``pages/dr-seuss.html`` and ``pages/author.html`` would be "
"checked for respectively."
msgstr ""
"La vista ``mezzanine.pages.views.page`` se encarga de retornar una instancia "
"``Page`` a una plantilla. Por defecto se utiliza la planitlla ``pages/page."
"html``, pero si existe una plantilla personalizada se utilizará en su lugar. "
"Primero se verifica si existe una plantilla con la misma slug que la "
"instancia ``Page``. Si no se encuentra, se busca una plantilla con un nombre "
"derivado de la subclase del modelo. Para el ejemplo anterior, se buscarían "
"las planitllas ``pages/dr-seuss.html`` y ``pages/author.html`` "
"respectivamente."

#: ../content-architecture.rst:214
msgid ""
"The view function further looks through the parent hierarchy of the "
"``Page``. If a ``Page`` instance with slug ``authors/dr-seuss`` is a child "
"of the ``Page`` with slug ``authors``, the templates ``pages/authors/dr-"
"seuss.html``, ``pages/authors/dr-seuss/author.html``, ``pages/authors/author."
"html``, ``pages/author.html``, and ``pages/page.html`` would be checked for "
"respectively. This lets you specify a template for all children of a "
"``Page`` and a different template for the ``Page`` itself. For example, if "
"an additional author were added as a child page of ``authors/dr-seuss`` with "
"the slug ``authors/dr-seuss/theo-lesieg``, the template ``pages/authors/dr-"
"seuss/author.html`` would be among those checked."
msgstr ""
"La vista también verifica la jerarquía ascendente de la instancia ``Page``. "
"Si se tiene una instancia ``Page`` con el slug ``authors/dr-seuss`` y que es "
"hija de la ``Page`` con slug ``authors``, se buscarán todas estas "
"plantillas: ``pages/authors/dr-seuss.html``, ``pages/authors/dr-seuss/author."
"html``, ``pages/authors/author.html``, ``pages/author.html``, y ``pages/page."
"html``. Esto permite especificar una plantilla para todos los hijos de una "
"``Page`` y otra plantilla diferente para una ``Page`` en particular. Por "
"ejemplo, si se añade otro autor como hijo de ``authors/dr-seuss`` con el "
"slug ``authors/dr-seuss/theo-lesieg``, la plantilla ``pages/authors/dr-seuss/"
"author.html`` estaría entre las plantillas verificadas."

#: ../content-architecture.rst:226
msgid "Overriding vs Extending Templates"
msgstr "Sustituir vs Extender plantillas"

#: ../content-architecture.rst:228
msgid ""
"A typical problem that reusable Django apps face, is being able to extend "
"the app's templates rather than overriding them. The app will usually "
"provide templates that the app will look for by name, which allows the "
"developer to create their own versions of the templates in their project's "
"templates directory. However if the template is sufficiently complex, with a "
"good range of extendable template blocks, they need to duplicate all of the "
"features of the template within their own version. This may cause the "
"project's version of the templates to become incompatible as new versions of "
"the upstream app become available."
msgstr ""
"Un problema común con las aplicaciones reutilizables Django es ser capaces "
"de extender una plantilla de la aplicación en vez de sustituirla. La "
"aplicación usualmente provee plantillas que buscará por nombre, lo que "
"permite al desarrollador crear sus propias versiones de las plantillas en la "
"carpeta del proyecto. Sin embargo, si la plantilla es lo suficientemente "
"compleja y con una buena cantidad de bloques extensibles, el desarrollador "
"se verá en la necesidad de duplicar todas las características de la "
"plantilla en su propia versión. Esto puede causar que la versión del "
"proyecto de la plantilla se vuela incompatible a medida que sucedan cambios "
"en la aplicación original."

#: ../content-architecture.rst:239
msgid ""
"Ideally we would be able to use Django's ``extends`` tag to extend the app's "
"template instead, and only override the template blocks we're interested in. "
"The problem with this however, is that the app will attempt to load the "
"template with a specific name, so we can't override *and* extend a template "
"at the same time, as circular inheritance will occur, e.g. Django thinks the "
"template is trying to extend itself, which is impossible."
msgstr ""
"Idealmente se podría utilizar la etiqueta Django ``extends`` para extender "
"la plantilla de la aplicación y sólo tener que sustituir los bloques de "
"interés para el proyecto. El problema es que la aplicación tratará de cargar "
"la plantilla de acuerdo a un nombre específico, por lo que no se puede "
"sustituir *y* extender una plantilla al mismo tiempo, debido a la herencia "
"circular que ocurre. Al final Django cree que la plantilla trata de "
"extenderse a sí misma, lo que es imposible."

#: ../content-architecture.rst:247
msgid ""
"To solve this problem, Mezzanine provides the ``overextends`` template tag, "
"which allows you to extend a template with the same name. The "
"``overextends`` tag works the same way as Django's ``extends`` tag, (in fact "
"it subclasses it), so it must be the first tag in the template. What it does "
"differently is that the template using it will be excluded from loading when "
"Django searches for the template to extend from."
msgstr ""
"Para solucionar este problema Mezzanine provee la etiqueta ``overextends``, "
"que permite extender una plantilla con el mismo nombre. La etiqueta "
"``overextends`` funciona de la misma forma que la etiqueta Django "
"``extends`` (de hecho es una subclase de ella), por lo que debe ser la "
"primera etiqueta en aparecer en la plantilla. Lo que hace de manera "
"diferente es que la plantilla que la utilice será excluida del proceso de "
"carga cuando Django busque las plantillas para usar como base de la "
"extensión."

#: ../content-architecture.rst:255
msgid "Page Processors"
msgstr "Procesadores de página"

#: ../content-architecture.rst:257
msgid ""
"So far we've covered how to create and display custom types of pages, but "
"what if we want to extend them further with more advanced features? For "
"example adding a form to the page and handling when a user submits the form. "
"This type of logic would typically go into a view function, but since every "
"``Page`` instance is handled via the view function ``mezzanine.pages.views."
"page`` we can't create our own views for pages. Mezzanine solves this "
"problem using *Page Processors*."
msgstr ""
"Hasta ahora se ha cubierto como crear y mostrar tipos de página "
"personalizados, pero ¿qué pasa si se necesitan características más "
"avanzadas? Por ejemplo, añadir un formulario a una página y procesar los "
"datos cuando el usuario envía el formulario. Este tipo de lógica normalmente "
"iría en una vista, pero debido a que todas las instancias de ``Page`` son "
"manejadas por la vista ``mezzanine.pages.views.page``, no se pueden crear "
"vistas personalizadas para las páginas. Mezzanine resuelve este problema "
"utilizando *procesadores de páginas*."

#: ../content-architecture.rst:265
msgid ""
"*Page Processors* are simply functions that can be associated to any custom "
"``Page`` models and are then called inside the ``mezzanine.pages.views."
"page`` view when viewing the associated ``Page`` instance. A Page Processor "
"will always be passed two arguments - the request and the ``Page`` instance, "
"and can either return a dictionary that will be added to the template "
"context, or it can return any of Django's ``HttpResponse`` classes which "
"will override the ``mezzanine.pages.views.page`` view entirely."
msgstr ""
"Los *procesadores de páginas* no son más que funciones que pueden ser "
"asociadas a cualquier modelo ``Page`` personalizado para luego ser llamadas "
"por ``mezzanine.pages.views.page`` cuando se visualiza una instancia "
"``Page`` relacionada. Un procesador de página siempre recibe dos argumentos "
"- la petición y la instancia ``Page``, y puede retornar un diccionario que "
"será añadido al contexto de la plantilla o cualquiera de las clases "
"``HttpResponse`` de Django para sustituir por completo a ``mezzanine.pages."
"views.page``."

#: ../content-architecture.rst:274
msgid ""
"To associate a Page Processor to a custom ``Page`` model you must create the "
"function for it in a module called ``page_processors.py`` inside one of your "
"``INSTALLED_APPS`` and decorate it using the decorator ``mezzanine.pages."
"page_processors.processor_for``."
msgstr ""
"Para asociar un procesador de página a un modelo ``Page`` personalizado se "
"debe crear una función para él en un módulo llamado ``page_processors.py`` "
"dentro de una de las aplicaciones en la lista ``INSTALLED_APPS`` y decorarla "
"usando el decorador ``mezzanine.pages.page_processors.processor_for``."

#: ../content-architecture.rst:279
msgid ""
"Continuing on from our author example, suppose we want to add an enquiry "
"form to each author page. Our ``page_processors.py`` module in the author "
"app would be as follows::"
msgstr ""
"Siguiendo con el ejemplo de los autores, se procederá a añadir un formulario "
"en la página de cada autor. Para ello se creará el módulo ``page_processors."
"py`` en la aplicación de autores con el siguiente contenido:"

#: ../content-architecture.rst:303
msgid ""
"The ``processor_for`` decorator can also be given a ``slug`` argument rather "
"than a Page subclass. In this case the Page Processor will be run when the "
"exact slug matches the page being viewed."
msgstr ""
"Al decorador ``processor_for`` también se le puede pasar un ``slug`` como "
"argumento en lugar de una subclase de ``Page``. En este caso el procesador "
"de página se ejecutará cuando el slug coincida con la página siendo "
"visualizada."

#: ../content-architecture.rst:308
msgid "Page Permissions"
msgstr "Permisos de páginas"

#: ../content-architecture.rst:310
msgid ""
"The navigation tree in the admin where pages are managed will take into "
"account any permissions defined using `Django's permission system <http://"
"docs.djangoproject.com/en/dev/topics/auth/#permissions>`_. For example if a "
"logged in user doesn't have permission to add new instances of the "
"``Author`` model from our previous example, it won't be listed in the types "
"of pages that user can add when viewing the navigation tree in the admin."
msgstr ""
"El árbol de navegación en la interfaz administrativa donde se gestionan "
"todas las páginas tomará en cuenta cualquier permiso definido utilizando el "
"`sistema de permisos de Django <http://docs.djangoproject.com/en/dev/topics/"
"auth/#permissions>`_. Por ejemplo, si el usuario que ha iniciado sesión no "
"tiene permiso para añadir nuevas instancias del modelo ``Author`` del "
"ejemplo anterior, ese modelo no aparecerá en la lista de modelos disponibles "
"para añadir cuando el usuario visualice el árbol de navegación en la "
"interfaz administrativa."

#: ../content-architecture.rst:318
msgid ""
"In conjunction with Django's permission system, the ``Page`` model also "
"implements the methods ``can_add``, ``can_change``, ``can_delete``, and "
"``can_move``. These methods provide a way for custom page types to implement "
"their own permissions by being overridden on subclasses of the ``Page`` "
"model."
msgstr ""
"Además del sistema de permisos de Django, el modelo ``Page`` también "
"implementa los métodos ``can_add`` (puede añadir), ``can_change`` (puede "
"editar), ``can_delete`` (puede eliminar), y ``can_move`` (puede mover). "
"Estos métodos permiten a las subclases de ``Page`` implementar su propio "
"sistema de permisos."

#: ../content-architecture.rst:324
msgid ""
"With the exception of ``can_move``, each of these methods takes a single "
"argument which is the current request object, and return a Boolean. This "
"provides the ability to define custom permission methods with access to the "
"current user as well."
msgstr ""
"Con la excepción de ``can_move``, cada uno de éstos métodos toma un único "
"argumento, que la petición actual, y retorna un booleano. Esto permite "
"definir métodos de permisos personalizados con acceso al usuario actual."

#: ../content-architecture.rst:331
msgid ""
"The ``can_add`` permission in the context of an existing page has a "
"different meaning than in the context of an overall model as is the case "
"with Django's permission system. In the case of a page instance, ``can_add`` "
"refers to the ability to add child pages."
msgstr ""
"El permiso ``can_add`` en el contexto de una página existente tiene un "
"significado diferente al que tiene en el contexto del modelo en general, "
"como es el caso del sistema de permisos de Django. En el caso de una "
"instancia de un página, ``can_add`` se refiere a la habilidad de añadir "
"páginas hijas."

#: ../content-architecture.rst:336
msgid ""
"The ``can_move`` method has a slightly different interface, as it needs an "
"additional argument, which is the new parent should the move be completed, "
"and an additional output, which is a message to be displayed when the move "
"is denied. The message helps justify reverting the page to its position "
"prior to the move, and is displayed using Django messages framework. Instead "
"of a Boolean return value, ``can_move`` raises a ``PageMoveException`` when "
"the move is denied, with an optional argument representing the message to be "
"displayed. In any case, ``can_move`` does not return any values."
msgstr ""
"El método ``can_move`` tiene una interfaz ligeramente diferente, ya que "
"necesita un argumento adicional: el nuevo padre que tendrá la página si se "
"completa el movimiento; y debe proveer una salida adicional: el mensaje que "
"se mostrará si se niega el movimiento. El mensaje justifica el regreso de la "
"página a la posición anterior, y se muestra utilizando el sistema de "
"mensajes de Django. En lugar de un valor booleano de retorno, ``can_move`` "
"levanta la excepción ``PageMoveException`` cuando el movimiento es denegado, "
"con el mensaje a mostrar como argumento opcional. En cualquiera caso, "
"``can_move`` no retorna ningún valor."

#: ../content-architecture.rst:348
msgid ""
"The ``can_move`` permission can only constrain moving existing pages, and is "
"not observed when creating a new page. If you want to enforce the same rules "
"when creating pages, you need to implement them explicitly through other "
"means, such as the ``save`` method of the model or the ``save_model`` method "
"of the model's admin."
msgstr ""
"El permiso ``can_move`` solo se aplica al movimiento de páginas existentes, "
"y no se toma en cuenta cuando se crea una nueva página. Si es necesario "
"aplicar las mismas reglas al crear páginas, será necesario implementarlas de "
"manera explícita a través de otros medios, como el método ``save`` del "
"modelo o el método ``save_model`` de la clase admin."

#: ../content-architecture.rst:355
msgid ""
"For example, if our ``Author`` content type should only contain one child "
"page at most, can only be deleted when added as a child page (unless you're "
"a superuser), and cannot be moved to a top-level position, the following "
"permission methods could be implemented::"
msgstr ""
"Por ejemplo, se pueden definir permisos para que el modelo ``Author`` cumpla "
"con estas reglas: sólo debe contener un máximo de un descendiente, sólo "
"puede ser eliminado cuando es añadido como hijo (a menos que se sea un "
"superusario), y no puede ser movido a una posición de primer nivel en el "
"árbol::"

#: ../content-architecture.rst:377
msgid "Page Menus"
msgstr "Menús de páginas"

#: ../content-architecture.rst:379
msgid ""
"We've looked closely at the aspects of individual pages, now let's look at "
"displaying all of the pages as a hierarchical menu. A typical site may "
"contain several different page menus, for example a menu that shows primary "
"pages on the header of the site, with secondary pages as drop-down lists. "
"Another type of menu would be a full or partial tree in a side-bar on the "
"site. The footer may display a menu with primary and secondary pages grouped "
"together as vertical lists."
msgstr ""
"Se han explorado en detalle los aspectos de las páginas individuales, ahora "
"se verá como mostrarlas en un menú jerárquico. Un sitio web típico puede "
"contener varios menús de páginas, por ejemplo, un menú que muestra las "
"páginas primarias en la cabecera del sitio, con las páginas secundarias como "
"listas desplegables. Otro tipo de menú podría ser un árbol completo o "
"parcial en la barra lateral del sitio. También el pie de página podría "
"mostrar un menú con las páginas primarias y secundarias agrupadas en listas "
"verticales."

#: ../content-architecture.rst:387
msgid ""
"Mezzanine provides the ``page_menu`` template tag for rendering the above "
"types of page menus, or any other type you can think of. The ``page_menu`` "
"template tag is responsible for rendering a single branch of the page tree "
"at a time, and accepts two optional arguments (you'll usually need to supply "
"at least one of them) in either order. The arguments are the name of a menu "
"template to use for a single branch within the page tree, and the parent "
"menu item for the branch that will be rendered."
msgstr ""
"Mezzanine provee la etiqueta de plantilla ``page_menu`` para generar los "
"tipos menú anteriores, o cualquier otro tipo que se pueda imaginar. La "
"etiqueta ``page_menu`` es responsable de generar una sola rama del árbol de "
"páginas a la vez, y acepta dos argumentos opcionales (por lo general será "
"necesario proveer por lo menos uno de ellos) en cualquier orden. Los "
"argumentos son el nombre de la plantilla a utilizar para una sola rama del "
"árbol de navegación, y el elemento padre de la rama que será generada."

#: ../content-architecture.rst:396
msgid ""
"The page menu template will be provided with a variable ``page_branch``, "
"which contains a list of pages for the current branch. We can then call the "
"``page_menu`` template tag for each page in the branch, using the page as "
"the parent argument to render its children. When calling the ``page_menu`` "
"template tag from within a menu template, we don't need to supply the "
"template name again, as it can be inferred. Note that by omitting the parent "
"page argument for the ``page_menu`` template tag, the first branch rendered "
"will be all of the primary pages, that is, all of the pages without a parent."
msgstr ""
"A la plantilla del menú de página se le proveerá de una variable "
"``page_branch``, que contiene una lista de páginas para la rama actual. Se "
"puede llamar a la etiqueta ``page_menu`` para cada página en la rama, usando "
"la página como el argumento padre para generar sus hijos. Al llamar a la "
"etiqueta ``page_menu`` desde una plantilla de menú, no es necesario proveer "
"el nombre de la plantilla de nuevo, ya que puede ser inferido. Se debe notar "
"que si se omite el argumento padre de la etiqueta ``page_menu``, la primera "
"rama generada será la de páginas primarias, es decir, todas las páginas sin "
"padres."

#: ../content-architecture.rst:406
msgid ""
"Here's a simple menu example using two template files, that renders the "
"entire page tree using unordered list HTML tags::"
msgstr ""
"Se presenta un ejemplo sencillo de menú utilizando dos archivos de "
"plantillas y que genera el árbol de páginas completo usando listas no "
"ordenadas HTML::"

#: ../content-architecture.rst:424
msgid ""
"The first file starts off the menu without specifying a parent page so that "
"primary pages are first rendered, and only passes in the menu template to "
"use. The second file is the actual menu template that includes itself "
"recursively for each branch in the menu. We could even specify a different "
"menu template in the call to ``page_menu`` in our menu template, if we "
"wanted to use a different layout for child pages."
msgstr ""
"El primer archivo comienza el menú sin especificar una página padre para que "
"se generen las páginas primarias primero, y sólo define que plantilla de "
"menú se va a utilizar. El segundo archivo es la plantilla de menú en sí que "
"se incluye a ella misma de manera recursiva para cada rama del menú. Incluso "
"se podría especificar una plantilla de menú distinta en la llamada a "
"``page_menu`` si se quisiera utilizar una plantilla distinta para las "
"páginas hijas."

#: ../content-architecture.rst:432
msgid "Filtering Menus"
msgstr "Filtrando los menús"

#: ../content-architecture.rst:434
msgid ""
"Each ``Page`` instance has a field ``in_menus`` which specifies which menus "
"the page should appear in. In the admin interface, the ``in_menus`` field is "
"a list of checkboxes for each of the menu templates. The menu choices for "
"the ``in_menus`` field are defined by the ``PAGE_MENU_TEMPLATES`` setting, "
"which is a sequence of menu templates. Each item in the sequence is a three "
"item sequence, containing a unique ID for the template, a label for the "
"template, and the template path. For example in your ``settings.py`` module::"
msgstr ""
"Cada instancia de ``Page`` tiene un campo ``in_menus`` que especifica en qué "
"menús debe aparecer la página. En la interfaz administrativa, el campo "
"``in_menus`` aparece como una lista de casillas de verificación para las "
"plantillas de menú. Las opciones de menú para ``in_menus`` se definen en la "
"variable de configuración ``PAGE_MENU_TEMPLATES``, que es una secuencia de "
"plantillas de menú. Cada elemento es una secuencia de tres elementos que "
"son: un identificador único para la plantilla, un nombre para la plantilla, "
"y la ruta a la plantilla. Por ejemplo, se puede definir en el módulo "
"``settings.py``::"

#: ../content-architecture.rst:449
msgid ""
"Which of these entries is selected for new pages (all are selected by "
"default) is controlled by the ``PAGE_MENU_TEMPLATES_DEFAULT`` setting. For "
"example, ``PAGE_MENU_TEMPLATES_DEFAULT = (1, 3)`` will cause the admin "
"section to pre-select the \"Top navigation bar\" and the \"Footer\" when "
"using the example above."
msgstr ""
"Por defecto, todos los menús aparecen marcados en la lista de casillas de "
"verificación, pero este comportamiento se puede modificar en la variable de "
"configuración ``PAGE_MENU_TEMPLATES_DEFAULT``. Por ejemplo, definir "
"``PAGE_MENU_TEMPLATES_DEFAULT = (1, 3)`` hará que los menús \"Top navigation "
"bar\" y \"Footer\" aparezcan pre-marcados en la interfaz administrativa."

#: ../content-architecture.rst:455
msgid ""
"The selections made for the ``in_menus`` field on each page don't actually "
"filter a page from being included in the ``page_branch`` variable that "
"contains the list of pages for the current branch. Instead it's used to set "
"the value of ``page.in_menu`` for each page in the menu template, so it's up "
"to your menu template to check the page's ``in_menu`` attribute explicitly, "
"in order to exclude it::"
msgstr ""
"Las selecciones hechas en el campo ``in_menus`` de cada página en realidad "
"no evitan que sea incluida en la variable ``page_branch`` que contiene la "
"lista de las páginas en la rama actual. En su lugar, son utilizadas para "
"establecer el valor de ``page.in_menu`` para cada página de la plantilla del "
"menú, así que es responsabilidad del desarrollador verificar el atributo "
"``in_menu`` de manera explícita para cada página, para decidir si debe ser "
"excluida::"

#: ../content-architecture.rst:475
msgid ""
"Note that if a menu template is not defined in the ``PAGE_MENU_TEMPLATES`` "
"setting, the branch pages supplied to it will always have the ``in_menu`` "
"attribute set to ``True``, so the only way this will be ``False`` is if the "
"menu template has been added to ``PAGE_MENU_TEMPLATES``, and then *not* "
"selected for a page in the admin interface."
msgstr ""
"Nótese que si una plantilla de menú no está definida en la variable de "
"configuración ``PAGE_MENU_TEMPLATES``, las ramas de páginas que reciba "
"siempre tendrá el atributo ``in_menu`` establecido como ``True``, por lo que "
"la única forma en que el atributo será ``False`` es si la plantilla ha sido "
"añadida a ``PAGE_MENU_TEMPLATES`` y *no* ha sido seleccionada en la interfaz "
"administrativa."

#: ../content-architecture.rst:483
msgid "Menu Variables"
msgstr "Variables de menú"

#: ../content-architecture.rst:485
msgid ""
"The ``page_menu`` template tag provides a handful of variables, both in the "
"template context, and assigned to each page in the branch, for helping you "
"to build advanced menus."
msgstr ""
"La etiqueta de plantilla ``page_menu`` provee un puñado de variables, todas "
"incluidas en el contexto de la plantilla, y asignadas a cada página en la "
"rama, para ser útiles a la hora de construir menús avanzados."

#: ../content-architecture.rst:489
msgid "``page_branch`` - a list of pages for the current branch"
msgstr "``page_branch`` - una lista de páginas en la rama actual"

#: ../content-architecture.rst:490
msgid "``on_home`` - a boolean for whether the homepage is being viewed"
msgstr ""
"``on_home`` - booleano que representa si se está viendo la página de inicio "
"actualmente"

#: ../content-architecture.rst:491
msgid ""
"``has_home`` - a boolean for whether a page object exists for the homepage, "
"which is used to check whether a hard-coded link to the homepage should be "
"used in the page menu"
msgstr ""
"``has_home`` - booleano que corresponde a la existencia de una página de "
"inicio, utilizado para verificar si se debe usar una enlace fijo a la página "
"de inicio en el menú de página"

#: ../content-architecture.rst:494
msgid "``branch_level`` - an integer for the current branch depth"
msgstr "``branch_level`` - un entero para la profundidad de la rama actual"

#: ../content-architecture.rst:495
msgid ""
"``page_branch_in_menu`` - a boolean for whether this branch should be in the "
"menu (see \"filtering menus\" below)"
msgstr ""
"``page_branch_in_menu`` - booleano que indica si la rama actual debe "
"aparecer en el menú (ver \"filtrando menús\" más abajo)"

#: ../content-architecture.rst:497
msgid "``parent_page`` - a reference to the parent page"
msgstr "``parent_page`` - una referencia a la página padre de la página actual"

#: ../content-architecture.rst:498
msgid "``page.parent`` - same as ``parent_page``."
msgstr "``page.parent`` - igual que ``parent_page``"

#: ../content-architecture.rst:499
msgid ""
"``page.in_menu`` - a boolean for whether the branch page should be in the "
"menu (see \"filtering menus\" below)"
msgstr ""
"``page.in_menu`` - booleano que indica si la página actual debe aparecer en "
"el menú (ver \"filtrando menús\" más abajo)"

#: ../content-architecture.rst:501
msgid ""
"``page.has_children`` - a boolean for whether the branch page has any child "
"pages at all, disregarding the current menu"
msgstr ""
"``page.has_children`` - booleano que indica si la página actual tiene "
"páginas hijas sin importar si aparecen en el menú o no"

#: ../content-architecture.rst:503
msgid ""
"``page.has_children_in_menu`` - a boolean for whether the branch page has "
"any child pages that appear in the current menu"
msgstr ""
"``page.has_children_in_menu`` - booleano que indica si la página actual "
"tiene páginas hijas que aparezcan en el menú actual"

#: ../content-architecture.rst:505
msgid ""
"``page.num_children`` - an integer for the number of child pages the branch "
"page has in total, disregarding the current menu"
msgstr ""
"``page.num_children`` - entero que indica el número de páginas hijas de la "
"página actual, sin importar si aparecen en el menú actual o no"

#: ../content-architecture.rst:507
msgid ""
"``page.num_children_in_menu`` - an integer for the number of child pages the "
"branch page has, that also appear in the current menu"
msgstr ""
"``page.num_children_in_menu`` - entero que indica el número de páginas hijas "
"de la página actual que si aparecen en el menú actual"

#: ../content-architecture.rst:509
msgid ""
"``page.is_current_child`` - a boolean for whether the branch page is a child "
"of the current page being viewed"
msgstr ""
"``page.is_current_child`` - booleano que indica si la página sobre la que se "
"está iterando es hija de la página que se está viendo"

#: ../content-architecture.rst:511
msgid ""
"``page.is_current_sibling`` - a boolean for whether the branch page is a "
"sibling (has the same parent) of the current page being viewed"
msgstr ""
"``page.is_current_sibling`` - booleano que indica si la página sobre la que "
"se está iterando es hermana (tiene el mismo padre) que la página que se está "
"visualizando"

#: ../content-architecture.rst:513
msgid ""
"``page.is_current_parent`` - a boolean for whether the branch page is the "
"direct parent of the current page being viewed."
msgstr ""
"``page.is_current_parent`` - booleano que indica si la página sobre la que "
"se está iterando es padre de la página siendo visualizada"

#: ../content-architecture.rst:515
msgid ""
"``page.is_current_or_ascendant`` - a boolean for whether the branch page is "
"the current page being viewed, or an ascendant (parent, grand-parent, etc) "
"of the current page being viewed"
msgstr ""
"``page.is_current_or_ascendant`` - booleano que indica si la página sobre la "
"que se está iterando es la página siendo visualizado o su ascendente (padre, "
"abuelo, etc)"

#: ../content-architecture.rst:518
msgid ""
"``page.is_primary`` - a boolean for whether the branch page is a primary "
"page (has no parent)"
msgstr ""
"``page.is_primary`` - booleano que indica si la página actual es una página "
"primaria (no tiene padre)"

#: ../content-architecture.rst:520
msgid ""
"``page.html_id`` - a unique string that can be used as the HTML ID attribute"
msgstr ""
"``page.html_id`` - una cadena única que puede utilizarse como el atributo "
"HTML ID"

#: ../content-architecture.rst:522
msgid "``page.branch_level`` - an integer for the branch page's depth"
msgstr ""
"``page.branch_level`` - entero que indica la profundidad de la página sobre "
"la que se está iterando"

#: ../content-architecture.rst:524
msgid ""
"Here's a commonly requested example of custom menu logic. Suppose you have "
"primary navigation across the top of the site showing only primary pages, "
"representing sections of the site. You then want to have a tree menu in a "
"sidebar, that displays all pages within the section of the site currently "
"being viewed. To achieve this we recursively move through the page tree, "
"only drilling down through child pages if ``page.is_current_or_ascendant`` "
"is ``True``, or if the page isn't a primary page. The key here is the ``page."
"is_current_or_ascendant`` check is only applied to the primary page, so all "
"of its descendants end up being rendered. Finally, we also only display the "
"link to each page if it isn't the primary page for the section::"
msgstr ""
"A continuación se presenta un ejemplo de lógica personalizada de menú "
"comúnmente solicitado. Supóngase que se tiene una navegación principal con "
"las páginas primarias en la parte superior del sitio. Ahora se quiere "
"agregar una menú de árbol en la barra lateral que muestre todas las páginas "
"de la sección siendo visualizada. Para lograr esto, hay que moverse "
"recursivamente a través del árbol de páginas, entrando al siguiente nivel "
"sólo si ``page.is_currente_or_ascendant`` es ``True``, o si la página siendo "
"visualizada no es primaria. La clave aquí es que la verificación de ``page."
"is_current_or_ascendant`` solo se aplica a la página primaria para que todos "
"sus descendientes sean renderizados. Finalmente, sólo se muestra el enlace a "
"cada página si no es la página primaria de una sección::"

#: ../content-architecture.rst:553
msgid "Integrating Third-party Apps with Pages"
msgstr "Integración de aplicaciones de terceros con las Páginas"

#: ../content-architecture.rst:555
msgid ""
"Sometimes you might need to use regular Django applications within your "
"site, that fall outside of Mezzanine's page structure. Of course this is "
"fine since Mezzanine is just Django - you can simply add the app's "
"urlpatterns to your project's ``urls.py`` module like a regular Django "
"project."
msgstr ""
"A veces será necesario utilizar aplicaciones regulares Django que caigan "
"fuera de la estructura de páginas de Mezzanine. Esto no es ningún problema "
"porque Mezzanine es sencillamente Django - basta con añadir los urlpatterns "
"de la aplicación al módulo ``urls.py`` del proyecto como un proyecto Django "
"normal."

#: ../content-architecture.rst:561
msgid ""
"A common requirement however is for pages in Mezzanine's navigation to point "
"to the urlpatterns for these regular Django apps. Implementing this simply "
"requires creating a page in the admin, with a URL matching a pattern used by "
"the application. With that in place, the template rendered by the "
"application's view will have a ``page`` variable in its context, that "
"contains the current page object that was created with the same URL. This "
"allows Mezzanine to mark the ``page`` instance as active in the navigation, "
"and to generate breadcrumbs for the ``page`` instance as well."
msgstr ""
"Un requisito común es que las páginas de la navegación de Mezzanine apunten "
"a los urlpatterns de estas aplicaciones regulares Django. Implementar esto "
"requiere simplemente crear una página en la interfaz administrativa con la "
"URL coincidiendo con uno de los patrones de la aplicación. Con esto se logra "
"que la plantilla renderizada por la vista de la aplicación tenga una "
"variable ``page`` en su contexto, la cual contiene el objeto Page creado con "
"la misma URL. Este le permite a Mezzanine marcar la instancia de ``page`` "
"como activa en la navegación, y generar la ruta de páginas hasta la "
"instancia de ``page`` actual."

#: ../content-architecture.rst:571
msgid ""
"An example of this setup is Mezzanine's blog application, which does not use "
"``Page`` content types, and is just a regular Django app."
msgstr ""
"Un ejemplo de esta configuración es la aplicación de blog de Mezzanine, que "
"no utiliza los tipos de página ``Page``, y que es nada más una aplicación "
"Django regular."
